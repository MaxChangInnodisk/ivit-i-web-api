import sys, os, shutil, time, logging, copy, json
from typing import Tuple
from flask import current_app

from .parser import modify_task_json, modify_application_params, parse_task_info, write_json, check_src_type, str_to_json
from .common import gen_uuid, handle_exception, simple_exception
from ivit_i.app.handler import get_tag_app_list, get_app_list

DIV             = '-'*30
APP_KEY         = 'APPLICATION'
MODEL_KEY       = 'MODEL'
MODEL_APP_KEY   = 'MODEL_APP'
APP_MODEL_KEY   = 'APP_MODEL'
TAG_APP         = 'TAG_APP'
SRC_KEY         = "SRC"
UUID            = "UUID"
TASK            = "TASK"
APPLICATION     = "APPLICATION"
MODEL           = "MODEL"
SRC             = "SRC"

SRC_PROC        = "proc"

MODEL_EXT       = [ '.trt', '.engine', '.xml', '.xmodel' ] 

def get_task_uuid(task_name, fix_uuid=None):
    """ Return Task UUID """
    # Generate by name
    task_uuid = gen_uuid(name=task_name, len=8)

    # Return UUID generated by name
    if (task_name in current_app.config["UUID"].values()) and ( fix_uuid == None ):
        logging.debug("UUID ({}) had already exist.".format(task_uuid))
        return task_uuid

    # Update task_uuid 
    task_uuid = fix_uuid if fix_uuid else task_uuid

    logging.debug("{} UUID hash table! {}:{}".format( 
        "Fixed" if fix_uuid !=None else "Update", task_uuid, task_name ))
    
    # if not in app.config then update
    if (not task_uuid in current_app.config['UUID'].keys()):
        current_app.config["UUID"].update( { task_uuid: task_name } )

    return task_uuid 

def init_task_app(task_uuid):
    """ Initial application , app_model in configuration
    * args
        - application: relationship between the application and the task ( uuid ) 
        - app_model: relationship between the application and the model 
    """

    # initialize 
    task_apps = current_app.config['TASK'][task_uuid]['application']['name']
    info_table = {
        APP_KEY: task_uuid,
        APP_MODEL_KEY: current_app.config['TASK'][task_uuid]['model']
    } 
    
    # create key in config if needed
    for KEY in [APP_KEY, APP_MODEL_KEY, TAG_APP]:
        if not ( KEY in current_app.config ):
            current_app.config.update({ KEY: dict() })    

    # update information in app.config[...]
    if (task_apps != []) or (task_apps != None) or (task_apps != ""):
        # capture the application information and make sure list and string both are work like a charm
        apps = [task_apps] if type(task_apps)==str else task_apps
        for app in apps:
            # update each KEY about application
            for KEY in [APP_KEY, APP_MODEL_KEY]:
                if not (app in current_app.config[KEY]): 
                    current_app.config[KEY].update( { app : list() } )    
                # update infomration
                info = info_table[KEY]
                if not (info in current_app.config[ KEY ][app]): 
                    current_app.config[ KEY ][app].append(info)
    
    if not bool(current_app.config[TAG_APP]):
        current_app.config[TAG_APP] = get_tag_app_list()

def init_task_model(task_uuid):
    """
    Initial model , model_app in configuration
        - model: relationship between the model and the task ( uuid ) 
        - model_app: relationship between the model and the application
    """
    task_framework = current_app.config['AF']
    task_tag = current_app.config['TASK'][task_uuid]['tag']
    task_model = current_app.config['TASK'][task_uuid]['model']
    task_apps = current_app.config['TASK'][task_uuid]['application']['name']
    # update the key in config
    for KEY in [MODEL_KEY, MODEL_APP_KEY]:
        if not ( KEY in current_app.config.keys()):
            current_app.config.update( {KEY:dict()} )
        if not (task_model in current_app.config[KEY].keys()):
            current_app.config[KEY].update( {task_model:list()} )
    # update task uuid in model
    
    if not (task_uuid in current_app.config[MODEL_KEY][task_model]):
        current_app.config[MODEL_KEY][task_model].append(task_uuid)

    # update application in model_app
    tag_app_list = current_app.config[TAG_APP] if ( TAG_APP in current_app.config ) else get_tag_app_list()

    for app in tag_app_list[task_tag]:
        if not (app in current_app.config[MODEL_APP_KEY][task_model]):
            current_app.config[MODEL_APP_KEY][task_model].append( app )
    
def init_task_src(task_uuid):
    """ 
    Initialize Source
        1. Update to app.config['SRC']
        2. Append the uuid into app.config['SRC'][{source}]["proc"]         # means process
        3. Check is the source is exist ( support v4l2 and any file, but excepted rtsp ... )
    """
    # get source and source type
    [ source, source_type ] = [ current_app.config['TASK'][task_uuid][key] for key in ['source', 'source_type'] ]
    # update information
    if not (source in current_app.config[SRC_KEY].keys()):
        logging.debug("Update source information")
        current_app.config[SRC_KEY].update({ 
            f"{source}" : { 
                "status": "stop",
                "proc": [],
                "type": source_type,
                "object": None,
                "detail": "",
            }})
    # Add process into config
    if not ( task_uuid in current_app.config['SRC'][ source ]['proc'] ):
        logging.debug("Update process into source config")
        current_app.config[SRC_KEY][ source ]['proc'].append(task_uuid)
    # Clear process which unused
    for uuid in current_app.config[SRC_KEY][ source ]['proc']:
        if not (uuid in current_app.config['UUID']):
            current_app.config[SRC_KEY][ source ]['proc'].remove(uuid)
    
def init_tasks(name:str, fix_uuid:str=None, index=0) -> Tuple[bool, str]:
    """  Initialize each AI Task.
    * args
        - name: task name
        - fix_uuid: if not setup, it will generated automatically 
    """
    [ logging.info(cnt) for cnt in [ DIV, f"[{index:02}] Start to initialize application ({name})"] ]

    # UUID
    task_path = os.path.join( current_app.config["TASK_ROOT"], name )
    task_uuid = get_task_uuid(task_name = name, fix_uuid = fix_uuid)

    # Parse the information about this task
    error, task_config, model_config = "", {}, {} 
    try:
        (task_config_path, model_config_path, task_config, model_config) = parse_task_info(name)
        task_status = "stop"

    except Exception as e:
        task_status = "error"
        error = simple_exception(e)
        
        logging.error(error)

    # -------------------------------------------------------------------------
    # Update basic information
    task_framework = task_config.get("framework", current_app.config.get("AF"))
    current_app.config["TASK"].update({ 
        task_uuid:{ 
            "name": name,
            "framework": task_framework, 
            "path": task_path,
            "status": task_status, 
            "error": error,
    }})

    if task_status == "error":
        logging.error('Initialize AI Task ({}) ... Failed'.format(name))
        return (task_status, task_uuid, current_app.config['TASK'][task_uuid])

    # -------------------------------------------------------------------------
    # Update information
    logging.debug("Update information to uuid ({})".format(task_uuid))

    # Double check application
    application_pattern = { "name": model_config["application"] } if type(model_config["application"])==str else model_config["application"]

    current_app.config["TASK"][task_uuid].update({    
        "tag": model_config["tag"],
        "application": application_pattern,
        "model": f"{model_config[task_framework]['model_path'].split('/')[-1]}",     # path to model
        "model_path": f"{model_config[task_framework]['model_path']}",     # path to model
        "label_path": f"{model_config[task_framework]['label_path']}",     # path to label 
        "config_path": f"{model_config_path}",             # path to model config
        "device": f"{model_config[task_framework]['device']}",
        "source" : f"{task_config['source']}",
        "source_type": f"{task_config['source_type'] if 'source_type' in task_config.keys() else check_src_type(app_cfg['source'])}",
        "output": None,
        "api" : None,       # api
        "runtime" : None,   # model or trt_obj
        "config" : model_config,    # model config
        "draw_tools" : None,
        "palette" : None, 
        "status" : "stop", 
        "cur_frame" : 0,
        "fps": None,
        "stream": None 
    })

    # -------------------------------------------------------------------------
    # Create new source if source is not in global variable
    init_task_src(   task_uuid )

    # Update the model list which could compare to the uuid who using this model
    init_task_model( task_uuid )   

    # Update the application mapping table: find which UUID is using the application
    init_task_app( task_uuid ) 

    logging.info('Initialize AI Task ({}:{}) ... Success'.format(name, task_uuid))
    
    return (task_status, task_uuid, current_app.config['TASK'][task_uuid])
 
def get_tasks(need_reset=False) -> list:
    """ Return Dictionary with `ready` and `failed` Task
    - args
        - need_reset: initialize each Task if need_reset=True 
    """

    ret = { "ready": [], "failed": [] }
    
    if need_reset:
        for idx, task in enumerate(os.listdir(current_app.config['TASK_ROOT'])):
            task_status, task_uuid, task_config = init_tasks(task, index=idx)

    for task_uuid in current_app.config['UUID']:

        task_config = current_app.config['TASK'][task_uuid]
        task_status = task_config['status']
        ret_status = "ready" if task_status!="error" else "failed"
        
        # parse ready and failed applications
        ret[ret_status].append({
            "tag": task_config.get('tag', ""),
            "framework": task_config['framework'], 
            "name": task_config['name'], 
            "uuid": task_uuid, 
            "status": task_status, 
            "error": task_config['error'], 
            "model": task_config.get('model'),
            "application": task_config.get('application')
        })

    return ret

def edit_task(form, src_uuid):
    """ Edit AI Task: Modify configuration and initalize again.
    - args
        - form: input data from request
        - src_uuid: to fix the uuid
    
    - return
        - init_tasks(...)
    """

    logging.info("Start to edit the task ({})".format(src_uuid))
    
    modify_task_json(   src_uuid = src_uuid,
                        task_name = form['name'],
                        form = form,
                        need_copy = False   )

    # Update UUID and TASK
    return init_tasks(form['name'], src_uuid)

def check_exist_task(task_path, need_create=False):
    """
    Double check task path and create it if need.
    """
    if os.path.exists(task_path):
        msg="Task is already exist !!! ({})".format(task_path)
        raise Exception(msg)
    else:
        if need_create: os.makedirs(task_path)
        logging.info('The new task path: {}'.format(task_path))

def add_task(form):
    """ Add a new AI task
    """
    
    # Get Basic Information
    task_name   = form['name']
    task_model  = form['model']
    task_path   = os.path.join( current_app.config['TASK_ROOT'] , task_name )
    
    # Check Name and Path
    if current_app.config['TASK'].__contains__(task_name):
        raise KeyError('AI Task ({}) already exist !!!'.format(task_name))
    
    if os.path.exists(task_path):
        raise FileExistsError("Can't create new AI Task ({}), path already exist !!!".format(task_path))
    
    same_model_uuids = current_app.config['MODEL'].get(task_model)
    if not same_model_uuids:
        raise KeyError("Unexcepted model name: {}.".format( task_model ))
    
    src_uuid = same_model_uuids[0] 

    # Modify task config
    modify_task_json(   src_uuid    = src_uuid,
                        task_name   = task_name,
                        form        = form,
                        need_copy   = True   )

    # Update UUID and TASK
    return init_tasks(task_name)

def remove_task(task_uuid):
    """ Remove AI Task with UUID """
    logging.info("Deleting AI Task ... ")

    # Get target task's basic information
    task_path   = current_app.config[TASK][task_uuid]['path']
    task_name   = current_app.config[UUID][task_uuid]

    # ---------------------------------------------------------------------
    # Remove Model Information
    # Get Model Path = If target task is an error task it would not have model_path
    task_model  = ""
    if current_app.config[TASK][task_uuid].__contains__("model_path"):
        task_model  = current_app.config[TASK][task_uuid]["model_path"].split('/')[-1]

    # Remove model-task relation
    if task_model in current_app.config[MODEL]:
        current_app.config[MODEL][task_model].remove(task_uuid)
        logging.warning(' - Remove {} in app.config[{}][{}]'.format(task_uuid, MODEL, task_model))

        # Check the current model is not using
        if current_app.config[MODEL][task_model] == []:
            current_app.config[MODEL_APP_KEY].pop(task_model, None)

            logging.warning(' - Remove {} from app.config[{}], please check /model_app'.format(
                task_model, MODEL_APP_KEY ))

    # ---------------------------------------------------------------------
    # Remove Application from app.config
    if current_app.config[TASK][task_uuid].__contains__(APPLICATION):
        task_app = current_app.config[TASK][task_uuid][APPLICATION]['name']
        task_app = [ task_app ] if type(task_app)==str else task_app

        # Delete UUID in each application ( Multi Application is supported )
        for app in task_app:
            current_app.config[APPLICATION][app].remove(task_uuid)
            logging.warning(' - Remove {} from app.config[{}][{}]'.format(
                task_uuid, APPLICATION, app
            ))

    # ---------------------------------------------------------------------
    # Remove UUID in app.config[source]
    if SRC in current_app.config[TASK][task_uuid]:
        task_src = current_app.config[TASK][task_uuid][SRC]
        current_app.config[SRC][ task_src ][SRC_PROC].remove(task_uuid)

        logging.warning(' - Remove {} from app.config[{}][{}][{}], check /src'.format(
            task_uuid,
            SRC,
            task_src,
            SRC_PROC
        ))

    # Remove UUID in config[UUID]
    current_app.config[UUID].pop(task_uuid, None)
    logging.warning(' - Pop out {} from app.config[{}]'.format(
        task_uuid, UUID ))
    
    # Remove task in config[TASK]
    current_app.config[TASK].pop(task_uuid, None)
    logging.warning(' - Pop out {} from app.config[{}]'.format(
        task_uuid, TASK ))
    
    # ---------------------------------------------------------------------
    # Remove Whole Task
    if os.path.exists(task_path): 
        shutil.rmtree(task_path)
        logging.warning(' - Remove Whole Task File ({})'.format(task_path))
    
    logging.info("Deleted AI Task: {}".format(task_uuid))


def get_model_config_template(task_tag):
    model_config = None
    logging.warning("Detect TAG: {}".format(task_tag))
    try:
        if task_tag == "cls":
            from ivit_i.cls.config_template import TEMPLATE as model_config
        elif task_tag == "darknet":
            from ivit_i.darknet.config_template import TEMPLATE as model_config
        elif task_tag == "obj":
            from ivit_i.obj.config_template import TEMPLATE as model_config
    except Exception as e:
        msg = handle_exception(e, "Could not get model configuration templates")
        logging.error(msg); raise ImportError(msg)

    return model_config

def copy_model_event(src_model_path, task_model_path):
    
    logging.info('Copy Model Event: From {} to {}'.format(src_model_path, task_model_path))

    os.rename( src_model_path, task_model_path )
    
    # if is openvino model, we have to copy the .bin and .mapping file
    if current_app.config["AF"] == "openvino":
        org_path = os.path.splitext(src_model_path)[0]
        trg_path = os.path.splitext(task_model_path)[0]

        ext_list = [ ".bin", ".mapping"]
        for ext in ext_list:
            org_file_path = "{}{}".format(org_path, ext)
            trg_file_path = "{}{}".format(trg_path, ext)
            
            if not os.path.exists(org_file_path):
                logging.error("Could not find {}, make sure the ZIP file is for Intel".format(org_file_path))
                return False

            os.rename( org_file_path, trg_file_path )
            logging.info("\t- Rename: {} -> {}".format(org_file_path, trg_file_path))

    return True

def copy_label_event(src, trg):
    
    logging.info('Copy Label Event')

    ret = True
    os.rename( src, trg )
    logging.info('\t- Rename: {} -> {}'.format(src, trg))
    return ret

def parse_train_config(train_config):
    """
    Parsing Train Configuration From iVIT-T ( input_size, preprocess, anchors, architecture_type).
    """

    # Init
    ret_dict = {}
    
    # Update Input Size
    h, w, c = train_config["model_config"]["input_shape"][:]
    ret_dict["input_size"] = "{},{},{}".format( c, h, w )

    # Set default pre-process
    ret_dict["preprocess"] = "caffe"
    
    # Update preprocess
    if "preprocess_mode" in train_config["train_config"]["datagenerator"] and train_config["platform"] != "openvino":
        ret_dict["preprocess"] = train_config["train_config"]["datagenerator"]["preprocess_mode"]
        logging.warning('Detect pre-process mode, set to: {}'.format(ret_dict["preprocess"]))
        
    # Update anchor
    if "anchors" in train_config:
        anchors = [ float(anchor.strip(" "))  for anchor in train_config["anchors"].split(",") ]
        ret_dict["anchors"] = anchors        
        ret_dict["architecture_type"] = "yolov4"

        logging.debug("Update anchor: {}".format(anchors))
        logging.debug("Update architecture: {}".format(ret_dict["architecture_type"]))

    return ret_dict

def import_task(form):
    """ Import new task according to the dictionaray data
    """
    logging.info('# Import a new AI Task')

    # get task_name and task_path
    task_name       = form['name'].strip()
    src_path        = form["path"]
    src_json_path   = form["json_path"]
    src_model_path  = form["model_path"]
    src_label_path  = form["label_path"]
    
    framework       = current_app.config['AF']
    task_dir        = current_app.config['TASK_ROOT']
    model_dir       = current_app.config['MODEL_DIR']
    
    src_model_name  = src_model_path.strip().split('/')[-1]
    src_label_name  = src_label_path.strip().split('/')[-1]
    src_model_pure_name   = os.path.splitext(src_model_name)[0]

    dst_model_dir   = os.path.join( model_dir, src_model_pure_name )
    task_path       = os.path.join( task_dir , task_name )
    
    # ------------------------------------------------------------------
    # Checking
    if src_model_path=="":
        raise Exception('Import Error: no model path in form data and could not find model in temporary folder ({}) ... '.format(src_path))

    # Create a new model folder
    if not os.path.exists(dst_model_dir): 
        os.makedirs( dst_model_dir )
        logging.info('  - Create a folder for new AI model ({})'.format(task_path))

    if not os.path.exists(task_path):
        os.makedirs(task_path)
        logging.info('  - Create a folder for new AI task ({})'.format(task_path))


    # define configuration path
    model_config_path = os.path.join( task_path, "{}.json".format( src_model_pure_name ))
    task_config_path = os.path.join( task_path, "task.json")

    # define task config parameters
    task_tag            = form["tag"]
    task_device         = form["device"]
    task_source         = form["source"]
    task_source_type    = form["source_type"]
    task_thres          = float(form["thres"])

    # concate target path
    dst_model_path = os.path.join( dst_model_dir, src_model_name )
    dst_label_path = os.path.join( dst_model_dir, src_label_name )
    
    # move the file and rename
    copy_model_flag = copy_model_event( src_model_path, dst_model_path )
    copy_label_flag = copy_label_event( src_label_path, dst_label_path )

    if( not ( copy_label_flag or copy_model_flag ) ):
        msg = "Something went wrong when copy file, please check log file. auto remove {}".format(task_path)
        shutil.rmtree( task_path ); raise Exception(msg)
    
    # generate model config json

    # if you have different key in configuration, you have to add 
    logging.info("Start to Generate Model Config ... ")
    
    # Get configuration template
    model_config = get_model_config_template(task_tag)    
    
    # modify the content
    model_config["tag"] = task_tag
    model_config[framework]["model_path"]   = dst_model_path
    model_config[framework]["label_path"]   = dst_label_path
    model_config[framework]["device"]       = task_device
    model_config[framework]["thres"]        = task_thres
    
    try:
        # update input_size, preprocess, anchors
        with open( src_json_path, "r" ) as f:
            train_config = json.load(f)
        model_config[framework].update( parse_train_config(train_config) )

        # write information into model config file
        with open( model_config_path, "w" ) as out_file:
            json.dump( model_config, out_file )
        logging.info("Generated Model Config \n{}".format(model_config))
    except Exception as e:
        raise Exception(handle_exception(e, 'Generated Modal Config Error'))

    # generate task config json

    logging.info("Start to Generate Task Config ... ")

    task_config = {}
    task_config["framework"]    = framework
    task_config["name"]         = task_name
    task_config["source"]       = task_source
    task_config["source_type"]  = task_source_type
    task_config["prim"] = { "model_json": model_config_path }

    # Update Application
    task_config.update( modify_application_params(form, {} ) )
    try:
        # write task config
        with open( task_config_path, "w") as out_file:
            json.dump( task_config, out_file)
        logging.info("Generated Task Config \n{}".format(task_config))
    except Exception as e:
        raise Exception(handle_exception(e, 'Generated Task Config Error'))

    # remove temperate file
    shutil.rmtree( src_path )
    logging.warning(f'Clear temperate task folder ({src_path})')
    
    logging.info("Finished Import Task !!!")
    return init_tasks( task_name )
    